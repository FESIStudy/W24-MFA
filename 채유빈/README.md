## 1. 개념 및 등장 배경

### 마이크로 프론트엔드란?

마이크로 프론트엔드는 **마이크로 서비스 아키텍처(Micro Service Architecture)의 철학**을 따르자는 접근 방식이다.

하나의 대형 프론트엔드 애플리케이션을 여러 개의 작고 독립된 단위로 분리하여, 각 모듈을 별도 팀이 독립적으로 개발, 테스트, 배포할 수 있게 만든다. 각 마이크로앱은 자체적인 개발 주기와 기술 스택, 배포 흐름을 가질 수 있으며, 궁극적으로 조직의 스케일업과 개발 속도의 병목 해소를 목적으로 한다.

<br/>

### MSA와의 관계

MFA는 백엔드 영역에서 널리 채택된 마이크로서비스 아키텍처(MSA)에서 영감을 받았다. MSA는 시스템을 여러 개의 독립적인 서비스로 분리하여 유지보수성과 확장성을 높이는데, 이 개념을 프론트엔드에도 적용하려는 시도가 바로 MFA다. 다만, 프론트엔드의 경우 화면 단위의 시각적 통합이 필수적이기 때문에, 기술적 제약과 사용자 경험의 연결 문제를 함께 해결해야 하는 점에서 구현이 더 복잡해진다.

<br/>

### SPA의 한계와 조직 구조 문제

SPA(Single Page Application)는 초기 진입 비용이 낮고, 유려한 사용자 경험을 제공할 수 있어 많은 서비스에서 채택되고 있다. 그러나 프로젝트 규모가 커질수록 한계가 분명히 드러난다. 예를 들어 수십 명 이상의 프론트엔드 개발자가 동시에 단일 저장소에서 작업하면, 빌드 시간은 기하급수적으로 늘어나고 코드 충돌도 빈번해진다. 도메인 간의 책임 분리가 어렵고, 기능 릴리즈 또한 중앙화된 빌드 프로세스에 종속되어 팀 간 독립성이 떨어진다.

이러한 문제는 기술적 문제만이 아닌 조직 구조의 병목으로 이어진다. 팀이 커지고 복잡해질수록 하나의 코드베이스를 함께 사용하는 구조는 점점 비효율적으로 변한다. 이에 따라 프론트엔드도 도메인별 책임 분리가 가능한 구조로 변화할 필요성이 대두된다.

<br/>

## 마이크로 프론트엔드의 철학과 등장 배경

MFA는 크게 다음과 같은 철학을 기반으로 한다.

1. **독립적인 개발과 배포**: 각 도메인( 기능(ex. 장바구니, 검색, 상품 상세 등) 중심의 도메인)은 독립적으로 개발되어야 하며, 서로 다른 주기와 전략으로 배포될 수 있어야 한다.
2. **기술 스택의 자유로움**: React, Vue, Angular 등 서로 다른 프레임워크도 공존할 수 있어야 한다.
3. **조직 구조와 기술 구조의 정렬**: 팀 조직은 기술 구조와 일치해야 하며, 이를 통해 커뮤니케이션 비용을 줄일 수 있다.

이러한 철학은 2016년 즈음부터 대규모 기업(Spotify, Zalando, IKEA 등)을 중심으로 실제 도입이 시작되었으며, 이후 커뮤니티의 발전과 함께 Webpack Module Federation, qiankun, Single-SPA 등 다양한 도구들이 등장하며 실현 가능성이 높아졌다.

<br/>

### 모놀리식 프론트엔드와의 비교

모놀리식 프론트엔드는 모든 기능이 하나의 앱, 하나의 코드베이스, 하나의 팀에 의해 유지된다. 이는 초기 개발 및 협업이 용이하지만, 점점 확장성이 떨어지고 코드 품질이 저하되며, 특정 기능에 문제가 생기면 전체 앱에 영향을 줄 수 있다.

반면 MFA는 다음과 같은 특징을 가진다:

- **기능 단위로 앱을 분리**: 각 도메인(예: 결제, 검색, 마이페이지 등)을 별도의 앱으로 나누어 관리한다.
- **팀 책임 분산**: 각 팀이 자신이 담당하는 앱만 책임지면 된다.
- **빠른 릴리즈**: 전체 빌드 없이도 해당 마이크로앱만 수정하여 배포할 수 있다.

<br/>

## 2. 아키텍처 패턴 분류 및 설계 전략

### 빌드 타임 통합 vs 런타임 통합

마이크로 프론트엔드를 구현할 때 가장 먼저 고려해야 할 것은 **어떤 방식으로 여러 앱을 통합할 것인가**에 대한 전략이다. 이를 크게 빌드 시 통합하는 방식과 런타임에 통합하는 방식으로 나눌 수 있다.

- **빌드타임 통합 (Static Integration)**
    - 말 그대로 각 마이크로 앱을 하나의 모놀리식 앱처럼 빌드 시점에 통합하는 방식
    - 상대적으로 구조가 단순하고 성능상 유리하다는 장점이 있다.
    - 예) `Nx`, `Turborepo`, `Lerna` 같은 모노레포 도구를 활용해 각 앱을 하나의 워크스페이스로 묶고 공통 빌드 파이프라인을 설정하는 방식
    - 장점
        - 빠른 초기 로딩 속도
        - 코드 최적화, Tree Shaking 유리
        - TypeScript 등 정적 분석에 유리
    - 단점
        - 팀 간 코드베이스 의존성이 강함
        - 개별 배포가 어렵고 전체 재배포 필요
        - 빌드 시간이 길어지고 병렬화가 어려움
    
    → 따라서 이 방식은 조직이 작고 프론트엔드 팀이 하나이거나, 제품이 일정 규모 이하인 경우 적합하다.
    
- **런타임 통합**
    - 각 마이크로앱을 독립적으로 빌드하고 배포한 뒤, 사용자 브라우저에서 앱을 동적으로 조합하여 하나의 UI처럼 렌더링하는 방식이다.
    - 대표적 방식 3가지
        1. **Client-side Integration**
            - SPA의 루트 앱(Shell 앱)에서 필요한 앱을 JavaScript로 불러와 DOM에 동적으로 삽입한다.
            - `Webpack Module Federation`이나 `Single-SPA`는 이러한 방식에 해당한다.
        2. **Server-side Composition**
            - 서버에서 각 마이크로앱의 HTML 조각을 가져와 하나의 페이지로 구성하여 클라이언트에 전달한다.
            - 이 경우 서버가 구성 책임을 가지며, SEO나 SSR과의 통합에 유리하다.
        3. **Edge-side Composition**
            - CDN이나 엣지 컴퓨팅 계층에서 HTML을 조합하는 방식이다.
            - 성능 최적화에 유리하지만 구현 난이도가 높다.
    - 장점
        - 각 앱의 배포와 릴리즈가 독립적
        - 기술 스택의 다양성 허용
        - 낮은 초기 진입 비용
    - 단점
        - 느린 초기 로딩 속도
        - 공통 라이브러리 중복 문제
        - 상태 및 라우팅 통합이 복잡
    
    → 대규모 조직에서 독립적인 배포, 다양한 기술 스택 사용이 필요한 경우에 적합하다.
    
<br/>

### Self-contained Systems (SCS)

Self-contained Systems는 **프론트엔드와 백엔드가 함께 묶인 독립적인 도메인 시스템**이다. 각 앱은 자체 API, UI, 데이터베이스까지 갖추며 완전히 독립된 배포 단위로 동작한다. 전통적인 마이크로서비스보다 더 강한 경계선을 가진 구조이다.

예를 들어 쇼핑몰에서 상품 조회, 주문, 배송 조회 등 기능을 각각의 SCS로 만들 수 있다. 각각은 별도의 마이크로 프론트엔드, 마이크로 백엔드, DB까지 갖춘다.

- **장점**
    - 팀 독립성과 책임 범위가 명확하다
    - 장애 격리와 유지보수가 용이하다
    - 전체 애플리케이션의 복잡도를 낮출 수 있다
- **단점**
    - 도메인 간 협업이 필요할 경우 중복 구현이 발생할 수 있다
    - 배포 환경 및 인프라가 복잡해질 수 있다

<br/>

### Vertical Slice Design (도메인 기반 분할)

MFA에서 가장 흔히 사용되는 전략은 수직 분할(Vertical Slicing)이다. 기능 중심이 아닌 **도메인 중심**으로 앱을 나누며, 각 팀이 해당 도메인의 프론트와 백엔드를 모두 소유하고 관리한다.

예를 들어, 장바구니 도메인 팀은 장바구니 UI, API, 상태관리, 모듈을 모두 담당한다. 이는 컨웨이의 법칙에 부합하는 구조로, 조직 구조가 자연스럽게 시스템 구조를 결정하도록 한다.

이러한 구조는 팀 간 충돌을 최소화하고 책임 영역을 명확히 하며, 각 팀의 기술적 선택과 업무 방식을 최대한 존중할 수 있다.

<br/>

### 마이크로 프론트엔드의 분할 기준

MFA는 단순히 앱을 나누는 것이 아니라 **왜, 어떻게 나눌지**에 대한 전략이 중요하다. 일반적으로 다음과 같은 기준을 복합적으로 고려한다.

1. **도메인 기준 분할**
    - 도메인 주도 설계(DDD)에 기반하여 기능 단위로 분할한다. 유지보수성과 명확한 책임 분리가 장점이다.
2. **팀 조직 기준 분할**
    - 각 팀의 역량, 규모, 책임 범위를 고려하여 자연스러운 분리를 한다. 팀이 곧 앱의 오너가 된다.
3. **기술 스택 기준 분할**
    - Vue, React, Svelte 등 다양한 기술 스택을 사용하는 조직이라면 기술별로 앱을 분리하는 것도 고려할 수 있다. 다만, 통합의 복잡성도 함께 증가한다.

<br/>

## 3. 구현 방식 및 주요 기술 스택

### Web Components 기반 구현

Web Components는 표준 웹 플랫폼 API를 통해 캡슐화된 UI 요소를 만들 수 있는 기술이다. 이는 프레임워크에 구애받지 않으며, Shadow DOM, Custom Elements, HTML Templates로 구성된다.

- 특징
    - 각 마이크로 앱을 Custom Element로 감싸고, 이를 루트 앱에서 `my-cart`, `my-profile`과 같은 방식으로 삽입할 수 있다.
    - Shadow DOM을 활용하여 스타일 격리가 가능하다.
    - 다양한 프레임워크와의 연동이 가능하다.
- 장점
    - 표준 기반이라 브라우저 호환성과 유지보수성이 좋다.
    - 기술 스택의 제약이 없고, 프레임워크 혼합 구성이 가능하다.
    - 강력한 스타일 캡슐화를 제공한다.
- 단점
    - 복잡한 상태 공유나 라우팅 연동이 어렵다.
    - SEO, SSR 적용이 제한된다.
    - 복잡한 로직 구현에는 다소 불편할 수 있다.

> Web Components는 기술 중립적인 조직이나, 다양한 프레임워크를 혼합 사용하는 환경에서 유리하다. 그러나 상태 공유가 많거나 SEO가 중요한 프로젝트에서는 다른 방식이 더 적합할 수 있다.
> 

<br/>

### iframe을 활용한 분리

가장 원시적이지만 가장 강력한 격리성과 보안성을 제공하는 방식이 iframe이다. 각 마이크로앱은 독립된 URL로 배포되고, 루트 앱에서 iframe 태그로 삽입하여 렌더링한다.

- 특징
    - 앱 간 완벽한 DOM 및 JS 겨길
    - 보안 측면에서 강력한 sandbox 옵션을 제공한다.
    - 배포 및 인증 처리가 단순하다.
- 장점
    - 충돌 가능성이 거의 없다. (스타일, 스크립트 격리)
    - 앱마다 도메인이 다르기 때문에 보안성이 높다.
    - 시스템 장애의 격리가 용이하다.
- 단점
    - UX가 끊기고, 렌더링 속도가 느리다.
    - SEO가 거의 불가능하다.
    - iframe 간 통신 구현이 복잡하다. (postMessage, BroadCastChannel 등 필요)

> iframe 기반 마이크로 프론트는 **보안이 최우선**이거나, 기존 앱을 점진적으로 통합해야 할 때 적합하다. 그러나 사용자 경험이나 SEO가 중요한 프로젝트에서는 피하는 것이 좋다.
> 

<br/>

### Module Federation 기반 동적 로딩

2020년 Webpack 5에서 도입된 Module Federation은 마이크로 프론트엔드 구현에서 가장 강력한 기능 중 하나다. 런타임에 외부에서 모듈을 불러와 사용할 수 있도록 하며, 서로 다른 앱 간 의존성 공유, 동적 로딩이 가능해진다.

- 구성 방식
    - **Host 앱**과 **Remote 앱**을 구성한다.
    - 각 Remote 앱은 `remoteEntry.js`를 통해 export 모듈을 정의한다.
    - Host 앱은 이를 런타임에 불러와서 사용할 수 있다.
    
    ```jsx
    // 예시: Host의 webpack.config.js
    remotes: {
      cartApp: 'cartApp@https://cdn.example.com/cart/remoteEntry.js',
    }
    ```
    
- 장점
    - 코드 분리가 자연스럽고, 앱 간 종속성이 낮다.
    - 공통 라이브러리를 `shared` 옵션으로 중복 로딩 없이 관리할 수 있다.
    - 마이크로앱을 **CDN으로 배포**하고 동적 로딩할 수 있다.
- 단점
    - 설정이 복잡하며 러닝 커브가 존재한다.
    - 버전 충돌 방지를 위해 shared dependency 관리를 신중히 해야 한다.
    - React Fast Refresh와 같은 개발 도구 호환성이 떨어질 수 있다.

> Module Federation은 현재 마이크로 프론트엔드에서 가장 주류로 자리 잡은 기술이다. 성능, 유지보수성, 확장성 측면에서 모두 뛰어나며, 복잡한 엔터프라이즈 환경에도 잘 적용된다.
> 

<br/>

### 프레임워크 비교

| 프레임워크 | 특징 | 장점 | 단점 |
| --- | --- | --- | --- |
| **Single-SPA** | 루트 앱에서 다양한 프레임워크를 조합 가능 | 독립 프레임워크 지원 | 복잡한 설정, 진입장벽 |
| **qiankun** | 알리바바의 Single-SPA 확장 버전 | 쉬운 API, 설정이 간단 | Vue에 최적화, 커뮤니티 제한 |
| **Module Federation** | Webpack 5 내장 기능 | 런타임 로딩, 성능 우수 | Webpack 의존, 설정 복잡 |
| **PirateShip** | Spotify 사내 프레임워크, SSR 지원 | SSR + Static 통합 가능 | 공개되지 않음, 문서 부족 |

> 이 중 가장 많이 사용되는 기술 조합은 `Module Federation + CDN 배포 + 런타임 통합` 구조이다.
> 

<br/>

### CDN을 이용한 Remote Entry 배포 전략

Module Federation이나 Web Components, iframe 기반 구조 모두에서 중요한 것은 **Remote Entry 파일을 어떻게 배포할 것인가**이다. 일반적으로는 각 마이크로앱의 `remoteEntry.js`, `main.js`, `chunk.js` 등을 CDN에 올려두고, Host 앱에서 해당 주소를 통해 동적으로 로딩한다.

```jsx
remotes: {
  profileApp: 'profileApp@https://cdn.example.com/profile/remoteEntry.js',
}
```

- 고려할 점
    - **캐시 전략**: `remoteEntry.js`는 버전이 바뀔 때마다 캐시가 갱신되어야 한다. 보통 쿼리 파라미터를 이용하거나, `hash`가 포함된 파일명을 사용한다.
    - **CDN 무중단 배포**: 트래픽이 몰리는 환경에서는 무중단 배포 전략이 필요하다. S3 + CloudFront를 조합해 Blue/Green 전략을 적용할 수 있다.
    - **버전 호환성 관리**: shared 설정에서 strictVersion 옵션을 활용하여 의도치 않은 충돌을 방지해야 한다.

<br/>

## 4. 상태 관리 및 데이터 공유 전략

마이크로 프론트엔드에서 가장 큰 고민 중 하나는 **마이크로앱 간의 상태를 어떻게 공유할 것인가**이다. SPA에서는 전역 상태 관리 라이브러리를 통해 손쉽게 상태를 공유할 수 있지만, MFA에서는 앱이 서로 독립적으로 구성되기 때문에 단일 전역 상태를 사용하는 것이 어렵거나 비효율적일 수 있다.

### 전역 상태 공유 vs 국소 상태 유지

MFA에서 상태 공유 전략은 크게 두 가지로 나눌 수 있다.

- **전역(Global) 상태 공유**: 여러 앱이 공통으로 사용하는 상태(ex. 로그인 정보, 사용자 ID)를 공유한다.
- **국소(Local) 상태 유지**: 각 앱은 자신의 상태만 관리하며, 필요한 경우에만 상태를 공유하거나 이벤트를 통해 통신한다.

전역 상태 공유는 직관적이지만 앱 간 의존도를 증가시키고, 런타임에서 충돌이 발생할 수 있다. 따라서 마이크로 프론트엔드의 핵심 철학인 **독립성과 캡슐화**를 유지하려면 **기본적으로 국소 상태 유지를 원칙으로 하고, 정말 필요한 경우에만 전역 상태 공유를 도입해야 한다.**

<br/>

### 상태 공유를 위한 대표 전략

1. **글로벌 상태 관리 도구 사용 (Redux, Zustand 등)**
    - 하나의 상태 라이브러리를 루트 앱에 설치하고, 마이크로 앱에서 해당 스토어를 참조하는 방식
    - 장점: 통일된 상태 관리 체계 제공, 디버깅 도구 활용 가능
    - 단점: 앱 간 결합도 상승, 상태 구조에 대한 사전 합의 필요
    
    > `Redux Toolkit`, `Zustand`, `MobX` 등 다양한 라이브러리를 활용할 수 있으나, 상태 구조의 사전 정의와 공유된 스토어의 의도치 않은 변경을 방지할 설계가 필요하다.
    > 
2. **EventBus, CustomEvent를 통한 브라우저 기반 통신**
    - 브라우저의 이벤트 시스템을 활용하여 마이크로앱 간 데이터를 주고받을 수 있다.
        
        ```jsx
        // 발신 앱
        window.dispatchEvent(new CustomEvent('userLogin', { detail: { userId: 'abc' } }));
        
        // 수신 앱
        window.addEventListener('userLogin', (e) => {
          const userId = e.detail.userId;
        });
        ```
        
    - 장점: 의존성 없이 느슨한 통신 가능, 다양한 프레임워크와 호환
    - 단점: 이벤트 흐름 추적이 어려워지고, 이벤트 버스 자체의 구조화가 필요
3. **Pub/Sub 패턴 활용**
    - `RxJS`, `Mitt`, `NanoEvents` 등의 이벤트 발행-구독 라이브러리를 이용하여 상태 변경을 감지하고 반응한다.
    - Pub/Sub은 이벤트 흐름을 체계적으로 관리할 수 있으며, 상태 공유뿐 아니라 기능 호출용 인터페이스로도 확장 가능하다.
4. **Cross-app context 전략** 
    - Host 앱에서 React Context 등을 정의하고, Remote 앱에서 해당 context를 참조하는 방식도 가능하다.
    - 이 방법은 React 기반 앱들에서 효과적이지만, 프레임워크 혼합 환경에서는 어려움이 있다.

<br/>

### 기술 스택 혼합 시 고려사항

MFA에서는 **React, Vue, Angular** 등 서로 다른 기술 스택이 공존할 수 있다. 이 경우 상태 공유는 더욱 어렵다.

- Web Components 방식의 Slot/Property 활용
- Shared Window Object 접근
- postMessage 활용한 iframe 간 통신

> 프레임워크 혼합 환경에서는 **메시지 기반 통신**이 가장 안전하고 실용적이다.
> 

<br/>

## 5. 라우팅 전략과 URL 구조

라우팅은 마이크로 프론트엔드에서 또 다른 핵심 이슈이다. 각 마이크로앱이 **자체 라우팅을 가질 것인지**, 아니면 **루트 앱에서 전체 라우팅을 제어할 것인지**에 따라 사용자 경험, SEO, 상태 동기화 방식이 크게 달라진다.

### 통합 라우터 vs 개별 라우터

- 통합 라우터 (Single Root Router)
    - 하나의 루트 앱이 전체 URL을 관리하며, 각 마이크로앱은 특정 경로에 매핑되어 로딩된다.
    - 이 방식은 `Single-SPA`, `Next.js + Module Federation` 등에서 흔히 사용된다.
    - 장점: 전체 URL 구조 통일, SEO 최적화 용이
    - 단점: 루트 앱의 복잡도 증가, 마이크로앱이 라우팅에 종속됨
- 개별 라우터 (Isolated Routing)
    - 각 마이크로앱이 자신의 라우터를 갖고 있으며, 루트 앱에서는 단순히 해당 앱을 불러와 삽입만 한다.
    - 이 방식은 iframe, Web Components 기반 구성에서 자연스럽게 적용된다.
    - 장점: 앱 독립성 보장, 개별 팀의 자유도 증가
    - 단점: URL Sync, 브라우저 히스토리 연동이 어려움

<br/>

### Nested Routing 구성

대부분의 현실적인 아키텍처는 통합 라우터와 개별 라우터의 혼합 구조를 사용한다. 루트 앱에서는 **대 카테고리** 수준의 라우팅을 제어하고, 마이크로앱 내부에서는 자체적으로 라우팅을 구성한다.

```jsx
// /mypage/profile → 루트에서 Mypage 앱 로딩 → Mypage 내부에서 profile 페이지 렌더링
```

이런 구성에서는 `history.pushState()`와 `popstate` 이벤트를 활용해 URL 변경과 화면 전환을 동기화해야 한다.

<br/>

### SEO 및 SSR 고려사항

SSR 또는 SEO가 중요한 서비스(예: 쇼핑몰, 미디어 플랫폼)에서는 URL 구조가 매우 중요하다.

- **Next.js + Module Federation**은 SSR과 MFA를 조합하기에 좋은 구조를 제공한다.
- 서버 측에서 HTML을 조합하는 Server-side Composition 방식이 SEO에 유리하다.

검색 엔진은 iframe 내부 콘텐츠나 동적 로딩된 JS 모듈을 탐색하지 못하므로, SSR 지원 여부는 전략적으로 중요하다.

<br/>

## 6. 스타일 격리 및 충돌 방지

마이크로 프론트엔드를 도입할 때 가장 빈번하게 마주치는 문제는 **스타일 충돌**이다. 서로 다른 앱에서 동일한 CSS 클래스 이름을 사용하거나 전역 스타일을 덮어쓰는 경우 UI가 깨지는 문제가 발생한다.

### CSS 스코핑 전략

1. **CSS Modules**
    - 각 컴포넌트의 CSS를 자동으로 고유한 이름으로 변환하여 적용한다. React, Vue 등에서 널리 사용되며, 스타일 충돌을 효과적으로 방지할 수 있다.
2. **BEM 방식**
    - Block-Element-Modifier 패턴으로 네이밍을 구조화하여 충돌 가능성을 낮춘다. 그러나 글로벌 네이밍이기 때문에 격리 수준은 낮다.
3. **Shadow DOM (Web Components)**
    - Web Components는 스타일 스코프를 강제로 분리하는 Shadow DOM을 기본적으로 제공한다. 가장 강력한 격리성을 제공하지만, CSS-in-JS와의 호환성 문제도 있다.

<br/>

### 전역 스타일 주입 방지

React의 styled-components, Emotion, Vue의 scoped style 등을 사용할 때도 **글로벌 스타일 누출**을 주의해야 한다.

- `createGlobalStyle`의 사용은 최소화한다.
- styled-components의 ThemeProvider는 앱마다 고립되도록 구성한다.
- 공통 reset.css는 가능한 한 CDN이나 루트 앱에서만 제공한다.

<br/>

### 스타일 충돌 사례와 해결 전략

| 문제 | 원인 | 해결 방법 |
| --- | --- | --- |
| 버튼 모양이 다르게 표시됨 | 공통 클래스 `btn`이 충돌 | CSS Module 또는 네임스페이스 사용 |
| 폰트 스타일이 전체에 적용됨 | 전역 `body` 스타일 적용 | CSS-in-JS로 지역화 또는 Scoped Style |
| 마이크로앱 사이의 스타일이 섞임 | iframe/X-Shadow DOM 미사용 | Shadow DOM 또는 iframe 사용 |

<br/>

### 디자인 시스템 통일 여부

디자인 시스템은 통일이 중요하지만, 마이크로앱별로 캡슐화된 환경에서는 도입 방식에 유의해야 한다.

- `Storybook` 등으로 공통 컴포넌트를 정의하고, NPM 패키지 또는 CDN으로 제공한다.
- 단일 ThemeProvider를 사용하는 경우 앱 간 충돌에 주의한다.
- 디자인 시스템은 기술이 아닌 조직 협업의 산물이므로, 버전 정책과 책임 주체를 명확히 해야 한다.

<br/>

## 7. 빌드 및 배포 전략

### 개별 빌드 vs 통합 빌드

마이크로 프론트엔드 구조에서는 각 앱을 **개별적으로 빌드**할 수 있는 구조가 선호된다. 이는 팀 간의 독립 배포를 가능하게 하며, 전체 앱의 릴리즈 주기에 영향을 받지 않고도 특정 도메인만 업데이트할 수 있게 해준다. 반면, 통합 빌드는 버전 호환성, 로딩 일관성 면에서 유리할 수 있지만 마이크로앱 간 강한 결합도를 유발하기 쉬우므로 주의가 필요하다.

현실적으로는 **하이브리드 형태**가 자주 사용된다. 예를 들어 core-shell 앱은 통합 빌드로 처리하고, 실제 기능 모듈은 CDN에서 동적으로 로딩되도록 구성하는 방식이다.

<br/>

### CI/CD 파이프라인 설계

MFA에서 CI/CD는 다음 두 가지 전략 중 하나로 접근한다.

- **개별 파이프라인 설계**: 각 마이크로앱마다 독립적인 CI/CD 설정을 갖고, GitHub Actions, GitLab CI, CircleCI 등으로 배포한다. 이 방식은 팀의 자율성과 속도를 보장하지만, 통합 테스트나 QA 환경 조율이 어려워질 수 있다.
- **통합 관리형 파이프라인**: monorepo 기반으로 전체 앱을 하나의 CI/CD 파이프라인에서 관리하되, 변경이 감지된 모듈만 선택적으로 빌드하고 배포한다. `Nx`나 `Turborepo`가 이 접근에 유용하다.

<br/>

### CDN을 활용한 Remote Entry 배포

Webpack Module Federation을 사용하는 경우, 각 마이크로앱은 **Remote Entry 파일을 CDN에 배포**하고, Host 앱 또는 다른 앱들이 이를 가져와서 실행하는 구조를 사용한다. 이 방식은 다음과 같은 이점을 가진다:

- Host 앱은 변경하지 않고도 마이크로앱의 기능을 업데이트할 수 있다.
- 캐시 정책에 따라 앱을 실시간으로 업데이트하거나 특정 버전만 유지할 수 있다.
- 서버 사이드에서 버전 라우팅 로직을 넣어 다양한 실험/롤백도 가능하다.

<br/>

### Lazy Loading 및 Dynamic Import 최적화

마이크로앱을 동적으로 로딩하기 때문에 **초기 렌더링을 최소화하고**, 사용자 흐름에 따라 필요한 시점에만 모듈을 로딩해야 한다. 이를 위해 `React.lazy`, `dynamic import`, `Suspense`, `prefetch` 메커니즘 등을 적극 활용한다.

<br/>

## 8. 성능 이슈 및 최적화 전략

마이크로 프론트엔드는 여러 앱을 런타임에서 조합하는 방식이기 때문에, 일반적인 SPA에 비해 초기 렌더링 시간이 길어질 수 있다. 특히 Host 앱과 Remote 앱 간의 의존 관계가 많을수록 번들 파싱, 모듈 연결 시간 등이 늘어난다.

이를 해결하기 위해 다음과 같은 전략을 병행한다.

- Remote 앱은 가능한 최소 모듈로 구성한다.
- shell 앱(호스트)은 공통 컴포넌트만 포함하고 기능은 런타임 로딩한다.
- 초기 렌더링에 필요한 앱만 미리 로딩하고, 나머지는 사용자 interaction에 따라 로딩한다.

<br/>

### 중복 로딩 방지

다수의 마이크로앱이 서로 다른 버전의 React, lodash 등 공통 라이브러리를 사용하면, 런타임에 번들 사이즈가 기하급수적으로 늘어나고, 충돌이 발생할 수 있다.

이를 방지하기 위해 **Webpack Module Federation의 `shared` 옵션**을 사용하여 라이브러리를 공유 구성한다. `singleton: true`, `eager: true` 등의 설정으로 중복 로딩을 막고, Host 앱이 버전 충돌을 제어할 수 있도록 만든다.

<br/>

### 번들 분리와 prefetch 전략

모듈 단위로 번들을 분리하고, 사용자 히스토리 기반으로 다음 페이지를 prefetch하여 로딩을 앞당길 수 있다. React Query, SWR 등과 연계하면 데이터를 미리 가져오고, Suspense와 함께 사용자 경험을 매끄럽게 유지할 수 있다.

<br/>

## 9. 보안 이슈 및 해결 방안

### Cross-Origin 및 iframe 보안 설정

iframe을 사용하는 구조에서는 cross-origin 문제가 자주 발생한다. 이를 해결하기 위해 다음과 같은 설정을 적용한다.

- `sandbox`, `allow-same-origin`, `allow-scripts` 속성을 통해 iframe 내부 기능 제한
- iframe 내 쿠키 접근을 막기 위해 서버에서 `SameSite=None; Secure` 쿠키 설정 필요
- CORS 정책을 통해 특정 도메인만 접근을 허용하거나 JWT 토큰을 헤더로 전송

<br/>

### 인증 처리 및 토큰 공유

마이크로앱이 분리되어 있더라도 공통 인증 시스템을 사용하는 경우가 많다. SSO(Single Sign-On), OAuth2, OpenID Connect 등을 활용하여 다음과 같은 방식으로 인증을 처리한다:

- 공통된 인증 서버에서 발급한 JWT를 로컬 스토리지 또는 쿠키에 저장
- iframe 기반 앱은 window.postMessage 또는 쿠키 공유 방식으로 인증 정보를 전달
- Auth Proxy 또는 BFF(Backend for Frontend) 계층을 둬 인증을 통합 처리

<br/>

### 보안 취약점 대응

MFA 구조는 XSS, CSRF 등 기존 SPA보다 더 많은 보안 경로를 가진다. 각 마이크로앱은 독립적으로 보안 취약점에 대응할 수 있어야 하며, 다음과 같은 공통 가이드라인을 적용해야 한다:

- HTML escape, CSP 정책 설정, iframe sandbox, JWT 유효성 검증
- CSRF Token 적용 또는 SameSite Cookie 정책
- 각 앱에서의 정적 분석, 코드 린팅, 보안 스캐닝

<br/>

## 10. 테스트 및 모니터링

### 마이크로앱 단위 테스트

각 앱은 독립적인 도메인 기능을 가지고 있으므로, 테스트도 **도메인 단위**로 분리된다. 단위 테스트는 React Testing Library, Jest, Vitest, Cypress 등으로 구성하며, 기능 별 테스트 스위트를 독립적으로 관리한다.

<br/>

### 통합 테스트 및 E2E 시나리오

전체 앱이 조합된 상태에서 동작을 보장하기 위해 통합 테스트도 필요하다. 다음과 같은 방식이 자주 사용된다:

- Cypress 기반의 End-to-End 테스트
- Playwright로 iframe을 포함한 시나리오 테스트
- Storybook으로 통합 UI 컴포넌트 테스트

<br/>

### 모니터링 및 로깅

각 앱에서 발생하는 에러, 성능, 사용자 행동을 추적하기 위해 **공통 로깅 및 모니터링 시스템**이 필요하다. 대표적인 도구로는 다음이 있다:

- Sentry, Datadog, LogRocket 등의 클라이언트 에러 추적 도구
- Grafana, Prometheus 기반 서버 모니터링
- 각 마이크로앱에 공통 로깅 SDK 삽입

<br/>

### 헬스 체크 및 장애 대응

마이크로앱이 다수 존재하므로, 특정 앱이 장애가 나더라도 전체 시스템에 영향을 주지 않아야 한다. CDN fallback, Lazy fallback UI, SLA 모니터링 등을 통해 장애에 유연하게 대응한다.

<br/>

# 11. 조직 협업 및 프로젝트 운영 전략

### 도메인 중심의 팀 조직

팀은 도메인 단위로 구성한다. 예를 들어 "결제팀", "마이페이지팀", "검색팀"은 각자 독립적인 앱을 담당하고, 해당 앱의 책임을 완전히 진다. 이를 통해 의사결정의 속도와 책임성을 높인다.

<br/>

### 공용 컴포넌트 관리

디자인 시스템, Button, Modal 등의 공용 컴포넌트는 별도의 공유 레포지토리 또는 NPM 패키지 형태로 제공한다. 이를 통해 중복 구현을 방지하고 UI/UX의 일관성을 유지한다. Storybook 기반 문서화, 자동 배포 CI/CD를 활용한다.

<br/>

### 버전 충돌과 릴리즈 전략

공용 패키지를 버전 업할 때는 SemVer를 엄격히 지키고, 각 앱이 사용하는 버전을 명시적으로 관리한다. Nx, Turborepo 같은 monorepo 도구를 활용하면 릴리즈 이력을 추적하고 종속성 문제를 자동 감지할 수 있다.

<br/>

### 협업 도구 및 리뷰 전략

- GitHub PR 단위 리뷰 + CI 테스트 자동화
- Slack, Linear, Notion을 통한 문서화 및 이슈 트래킹
- 팀 간 주기적인 tech sync와 통합 테스트 리포트 공유

<br/>

# 12. 실전 사례 분석 및 리스크 관리

### 도입 사례

- **Zalando**: 도메인 기반 마이크로 프론트 전략으로 각 팀이 자신의 서브도메인을 소유. Single-SPA 기반 시스템으로 독립 배포.
- **Spotify**: 사내 플랫폼 팀이 Shell 앱과 도구를 제공하고, 기능팀은 각자 모듈을 개발. iframe 구조를 통해 기술 독립성 유지.
- **DAZN**: 스포츠 스트리밍 특성상 퍼포먼스가 중요하여, 서버사이드 프리렌더링과 CDN 전략을 함께 사용.
- **IKEA**: 장바구니, 주문, 결제, 검색 등이 모두 독립 앱으로 구성되어 있고, Webpack Module Federation으로 통합.

<br/>

### 리팩토링 사례

초기에는 iframe 방식으로 시작했다가 SEO와 UX 문제로 인해 Module Federation 기반으로 전환한 사례가 많다. iframe은 기술 격리를 보장하지만 UX나 성능 측면에서 불리하기 때문이다.

<br/>

### 실패 사례와 교훈

- 앱 간 결합도가 높아 모듈화가 실패한 경우
- 공용 상태 공유가 실패하면서 버그가 확산된 사례
- 개별 배포 전략 미흡으로 릴리즈 속도가 오히려 늦어진 케이스

> MFA는 구조가 복잡한 만큼 명확한 분리 기준과 조직 운영 전략이 없으면 오히려 기술 부채를 키우는 결과를 초래할 수 있다.
>